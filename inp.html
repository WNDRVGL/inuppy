<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Event Message Wall</title>

  <!-- フォント（そのまま LINE Seed JP） -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LINE+Seed+JP:wght@400;700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#000;
      --dot: rgba(255,255,255,.05);
      --bezel: rgba(255,255,255,.08);
    }

    html, body{
      margin:0;
      height:100%;
      background:var(--bg);
      overflow:hidden;
      font-family:"LINE Seed JP", system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Meiryo", sans-serif;
    }

    /* 全画面 */
    .wrap{
      height:100%;
      width:100%;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }

    /* 電光掲示板っぽい下地（うっすらドット） */
    .wall{
      position:relative;
      flex:1;
      padding: clamp(10px, 1.6vh, 18px);
      box-sizing:border-box;
      background:
        radial-gradient(circle at 1px 1px, var(--dot) 1px, rgba(0,0,0,0) 1.7px) 0 0 / 9px 9px,
        radial-gradient(circle at 40% 20%, rgba(255,255,255,.06), rgba(0,0,0,0) 55%),
        radial-gradient(circle at 70% 80%, rgba(255,255,255,.05), rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0));
    }

    /* 画面を埋め尽くすグリッド */
    .grid{
      width:100%;
      height:100%;
      display:grid;
      gap: clamp(10px, 1.4vh, 18px);

      /* 端末サイズに応じてタイル数が自動で変わる */
      grid-template-columns: repeat(auto-fill, minmax(min(340px, 26vw), 1fr));
      grid-auto-rows: 1fr;
      align-content:stretch;
    }

    /* タイル（メッセージ枠） */
    .tile{
      position:relative;
      overflow:hidden;
      border-radius: 18px;
      padding: clamp(12px, 2.0vh, 18px);
      box-sizing:border-box;

      background:
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--bezel);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.06),
        inset 0 -16px 36px rgba(0,0,0,.72),
        0 18px 50px rgba(0,0,0,.55);
    }

    /* タイル内のLED面 */
    .tile::before{
      content:"";
      position:absolute;
      inset:10px;
      border-radius: 14px;
      background:
        radial-gradient(circle at 1px 1px, rgba(255,255,255,.05) 1px, rgba(0,0,0,0) 1.7px) 0 0 / 8px 8px,
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,0) 55%),
        linear-gradient(180deg, #0a0a0a, #000);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.05),
        inset 0 0 70px rgba(0,0,0,.88);
      pointer-events:none;
    }

    .text{
      position:relative;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;

      font-weight:800;
      /* 画面を埋める用途なので読みやすく大きめ */
      font-size: clamp(22px, 3.2vw, 56px);
      line-height: 1.15;
      letter-spacing: 0.02em;

      text-shadow:
        0 0 10px currentColor,
        0 0 22px currentColor,
        0 0 44px rgba(255,255,255,.12);
      filter: saturate(1.15) contrast(1.06);
      word-break: break-word;
      overflow:hidden;
    }

    /* 新着：0.2秒で出現（透明→表示 & 110%→100%） */
    .tile.pop{
      opacity: 0;
      transform: scale(1.06);
      animation: popIn 0.2s ease-out forwards;
    }
    @keyframes popIn{
      0%   { opacity: 0; transform: scale(1.06); }
      100% { opacity: 1; transform: scale(1.00); }
    }

    /* 新着：一瞬フラッシュ */
    .tile.flash{
      animation: flashOnce 0.35s ease-out 1;
    }
    @keyframes flashOnce{
      0%   { filter: brightness(1.0); }
      20%  { filter: brightness(2.2); }
      100% { filter: brightness(1.0); }
    }

    .status{
      position: fixed;
      left: 12px;
      bottom: 10px;
      font-size: 12px;
      color: rgba(255,255,255,0.55);
      user-select:none;
      font-weight: 700;
      letter-spacing: .2px;
      pointer-events:none;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="wall">
      <div id="grid" class="grid" aria-label="メッセージウォール"></div>
    </div>
  </div>

  <div id="status" class="status">connecting…</div>

  <script>
    // Apps Script WebアプリURL(/exec) ※変更したものを使用
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzLnD6M9UcMuxu-u4AzM_aOY_8yBR90NNPSYQp4rAVczef8jWkYiFrkxv3N2UQMivI2/exec";

    // C列固定（GAS側がC列のみ返す前提でも、HTMLから送っておく）
    const TARGET_COL = "C";

    // 10秒更新
    const POLL_MS = 10000;

    // 色ランダム
    const COLORS = ["#ffff00", "#ffffff", "#ff1493"];

    const grid = document.getElementById("grid");
    const statusEl = document.getElementById("status");

    let lastRowSeen = 1;
    const seenKeys = new Set();

    function setStatus(t){ statusEl.textContent = t; }
    function pickColor(){ return COLORS[Math.floor(Math.random() * COLORS.length)]; }

    // JSONP（CORS回避）
    function fetchJSONP(url, params = {}) {
      return new Promise((resolve, reject) => {
        const cbName = "cb_" + Math.random().toString(36).slice(2);
        const script = document.createElement("script");

        const q = new URLSearchParams({
          ...params,
          callback: cbName,
          t: String(Date.now())
        });

        const cleanup = () => {
          try { delete window[cbName]; } catch {}
          script.remove();
        };

        window[cbName] = (data) => { cleanup(); resolve(data); };

        script.onerror = () => {
          cleanup();
          reject(new Error("JSONP load error"));
        };

        script.src = url + (url.includes("?") ? "&" : "?") + q.toString();
        document.body.appendChild(script);

        setTimeout(() => {
          if (window[cbName]) {
            cleanup();
            reject(new Error("JSONP timeout"));
          }
        }, 8000);
      });
    }

    // 画面を「埋め尽くす」ため、常に表示可能数を超えたら古いタイルを削除
    function maxTiles(){
      // 実際の見た目に合わせて自動計算
      const rect = grid.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      // minmax(min(340px, 26vw), 1fr) の概算：列数を推定
      const colWidth = Math.min(340, w * 0.26);
      const cols = Math.max(1, Math.floor(w / (colWidth + 12))); // gap概算
      const rows = 3; // 高さは「だいたい3段」想定（端末で変動するが十分実用）
      // ※より厳密にしたければ計算を細かくできます
      return Math.max(6, cols * rows);
    }

    function appendTile(text, rowId){
      const clean = String(text || "").trim();
      if(!clean) return;

      const key = (rowId != null) ? `row:${rowId}` : `txt:${clean}`;
      if(seenKeys.has(key)) return;
      seenKeys.add(key);

      const tile = document.createElement("div");
      tile.className = "tile pop flash";

      const t = document.createElement("div");
      t.className = "text";
      t.textContent = "#" + clean;
      t.style.color = pickColor();

      tile.appendChild(t);
      grid.appendChild(tile);

      // 埋め尽くし：上限を超えたら古いものから削除
      const limit = maxTiles();
      while(grid.children.length > limit){
        grid.removeChild(grid.firstElementChild);
      }

      // アニメクラス外し（軽量化）
      setTimeout(() => tile.classList.remove("pop"), 250);
      setTimeout(() => tile.classList.remove("flash"), 500);
    }

    async function poll(){
      try{
        const data = await fetchJSONP(SCRIPT_URL, {
          since: String(lastRowSeen),
          col: TARGET_COL
        });

        if(data && data.ok){
          const msgs = Array.isArray(data.messages) ? data.messages : [];
          msgs.forEach(m => {
            if(m && m.text) appendTile(m.text, m.row);
          });

          const lr = Number(data.lastRow || lastRowSeen);
          if(Number.isFinite(lr)) lastRowSeen = Math.max(lastRowSeen, lr);

          setStatus(`ok | wall | col=${TARGET_COL} | lastRow=${lastRowSeen} | shown=${seenKeys.size}`);
        } else {
          setStatus("response not ok");
        }
      } catch (e){
        setStatus("error: " + e.message);
      }
    }

    function init(){
      poll();
      setInterval(poll, POLL_MS);

      // 画面回転などで上限枚数が変わるので、resize時に古いのを間引く
      window.addEventListener("resize", () => {
        const limit = maxTiles();
        while(grid.children.length > limit){
          grid.removeChild(grid.firstElementChild);
        }
      });
    }

    init();
  </script>
</body>
</html>
